<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ansible on Keep calm and write something</title><link>https://cychong47.github.io/tags/ansible/</link><description>Recent content in Ansible on Keep calm and write something</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 14 Jun 2018 15:21:32 +0000</lastBuildDate><atom:link href="https://cychong47.github.io/tags/ansible/index.xml" rel="self" type="application/rss+xml"/><item><title>Update ansible-playbook for wordpress</title><link>https://cychong47.github.io/post/2018/update-ansible-playbook-for-wordpress/</link><pubDate>Thu, 14 Jun 2018 15:13:52 +0900</pubDate><guid>https://cychong47.github.io/post/2018/update-ansible-playbook-for-wordpress/</guid><description>이상하게 wordpress 버전이 올라가면 docker용 wordpress 버전도 함께 올라갈 텐데 아무리 최신 docker image를 받아 container를 만들어도 wordpress admin 계정에 들어가면 wordpress를 업데이트 해야 한다고 한다. docket store(http://store.docker.com)에 가면 분명히 wordpress 최신 버전으로 패키징되어 있는 데&amp;hellip;
혹시나 하고 ansible-playbook을 보니 /var/www/html에 마운트되는 위치에 이전 버전의 wordpress 파일들이 존재하고 있었다.
volumes: - &amp;#34;/Users/cychong/Documents/wordpress/html:/var/www/html&amp;#34; - &amp;#34;/Users/cychong/Documents/wordpress/uploads:/var/www/html/wp-content/uploads&amp;#34; - &amp;#34;/Users/cychong/Documents/wordpress/conf/php_uploads.ini:/usr/local/etc/php/conf.d/uploads.ini&amp;#34; 바로 첫번째 줄이 문제를 유발하고 있는 곳&amp;hellip; 내가 왜 굳이 저렇게 했을까 생각해 보니 저 디렉토리에 바로 wp-content가 있고, 그 아래 themes와 plugins가 있다.</description></item><item><title>Ansible - Install homebrew</title><link>https://cychong47.github.io/post/2017/ansible-homebrew/</link><pubDate>Sat, 30 Dec 2017 02:34:39 +0900</pubDate><guid>https://cychong47.github.io/post/2017/ansible-homebrew/</guid><description>update homebrew mbpr15:mp3 cychong$ ansible all -m homebrew -a update_homebrew=yes localhost | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: true, &amp;#34;msg&amp;#34;: &amp;#34;Homebrew updated successfully.&amp;#34; } mini2 | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: true, &amp;#34;msg&amp;#34;: &amp;#34;Homebrew updated successfully.&amp;#34; } upgrade all packages mbpr15:mp3 cychong$ ansible all -m homebrew -a update_homebrew=yes -a upgrade_all=yes localhost | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: true, &amp;#34;msg&amp;#34;: &amp;#34;Homebrew upgraded.&amp;#34; } mini2 | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: true, &amp;#34;msg&amp;#34;: &amp;#34;Homebrew upgraded.&amp;#34; } install a package mbpr15:mp3 cychong$ ansible all -m homebrew -a name=neovim -a state=present mbpr15:~ cychong$ cat install_brew_neovim.</description></item><item><title>Ansible - recreate ghost container</title><link>https://cychong47.github.io/post/2017/recreate-ghost-container/</link><pubDate>Sat, 30 Dec 2017 02:31:41 +0900</pubDate><guid>https://cychong47.github.io/post/2017/recreate-ghost-container/</guid><description>YAML file state:absent 는 현재 존재하는 container를 중지시키고, 삭제한다. 단순히 stop만 시키려면 state:stopped로 지정하면 된다.
pull: yes 옵션을 사용하면 항상 최신 image를 pull한다고 한다.
recreate Use with present and started states to force the re-creation of an existing container.
mbpr15:ansible cychong$ cat recreate_container_ghost.yaml --- - hosts: mini2 tasks: - name: Stop and remove contianer docker_container: name: ghost state: absent - name: Create ghost Container docker_container: name: ghost image: ghost # always pull the latest image pull: yes state: started recreate: yes volumes: - &amp;#34;/Users/cychong/Dropbox/Apps/ghost/content/:/var/lib/ghost/content&amp;#34; - &amp;#34;/Users/cychong/Dropbox/Apps/ghost/config.</description></item><item><title>Ansible - basics of ansible-playbook</title><link>https://cychong47.github.io/post/2017/ansible-playbook/</link><pubDate>Fri, 29 Dec 2017 13:43:14 +0900</pubDate><guid>https://cychong47.github.io/post/2017/ansible-playbook/</guid><description>play The goal of a play is to map a group of hosts to some well defined roles, represented by things ansible calls tasks. At a basic level, a task is nothing more than a call to an ansible module
play는 명령을 수행할 대상과 수행할 명령을 모두 포함하고 있다.
playbook playbook은 하나 혹은 이상의 play들의 집합으로 정의한다.
Conventional template of playbook --- - hosts: XXX optoins.... tasks: -name: YYY MODULE_NAME : MODULE_ARGS -name : ZZZ MODULE_NAME: MODULE_ARGS .</description></item><item><title>Ansible - ad-hoc or basic</title><link>https://cychong47.github.io/post/2017/ansible-exercise-1/</link><pubDate>Wed, 27 Dec 2017 14:32:51 +0900</pubDate><guid>https://cychong47.github.io/post/2017/ansible-exercise-1/</guid><description>Create inventory(Ansible hosts) file mbpr15:Homebrew cychong$ cat /etc/ansible/hosts mini1 ansible_host=x.y.z.a ansible_ssh_user=cychong ansible_ssh_port=22 mini2 ansible_host=x.y.z.b ansible_ssh_user=cychong ansible_ssh_port=22 localhost ansible_connection=local ping ping 명령도 ansible이 제공하는 ping module을 이용하므로 -m 옵션을 사용한다.
mbpr15:Homebrew cychong$ ansible all -m ping -k SSH password: localhost | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: false, &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34; } mini2 | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: false, &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34; } mini1 | UNREACHABLE! =&amp;gt; { &amp;#34;changed&amp;#34;: false, &amp;#34;msg&amp;#34;: &amp;#34;timed out&amp;#34;, &amp;#34;unreachable&amp;#34;: true } ssh의 로그인 ID는 /etc/ansible/hosts에 기술하거나 명령어 옵션 —user=cychong으로 지정할 수 있다.</description></item><item><title>Error in using homebrew module in ansible</title><link>https://cychong47.github.io/post/2017/untitled-2/</link><pubDate>Sun, 08 Oct 2017 17:25:43 +0900</pubDate><guid>https://cychong47.github.io/post/2017/untitled-2/</guid><description>When I call the homebrew modules for three hosts including the localhost, one host reports error.
mbpr15:~ cychong$ ansible-playbook install_brew_ack.yaml --verbose No config file found; using defaults PLAY [all] ************************************************************************************************** TASK [Gathering Facts] ************************************************************************************** ok: [localhost] ok: [mini2] ok: [mini1] TASK [install ack in homebrew] ****************************************************************************** ok: [localhost] =&amp;gt; {&amp;#34;changed&amp;#34;: false, &amp;#34;failed&amp;#34;: false, &amp;#34;msg&amp;#34;: &amp;#34;Package already installed: ack&amp;#34;} ok: [mini1] =&amp;gt; {&amp;#34;changed&amp;#34;: false, &amp;#34;failed&amp;#34;: false, &amp;#34;msg&amp;#34;: &amp;#34;Package already installed: ack&amp;#34;} fatal: [mini2]: FAILED!</description></item><item><title>Play with Ansible</title><link>https://cychong47.github.io/post/2017/ansible/</link><pubDate>Wed, 04 Oct 2017 00:22:48 +0900</pubDate><guid>https://cychong47.github.io/post/2017/ansible/</guid><description>Configuration ansible client A ansible target B, C In client Ansible targets(B,C) should be listed in the following file. If required additional parameters can be specified such as login account, ssh port and etc
# /etc/ansible/hosts 192.168.1.100 ansible_ssh_user=cychong ansible_ssh_port=22 192.168.1.200 ansible_ssh_user=cychong ansible_ssh_port=22 In ansible targets A should be found on the following file
# grep A .ssh/authorized_keys Test run from A # ansible all -m ping 192.168.1.200 | SUCCESS =&amp;gt; { &amp;#34;changed&amp;#34;: false, &amp;#34;failed&amp;#34;: false, &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34; } 192.</description></item></channel></rss>